									Design Principles: Part 1

1. Measuring Quality of Design
	
	An incremental, iterative process

	Difficult to design right the first time, good design have to evolve and not done in one sitting.

2. Metrics for class design

	- Coupling

		Inheritance vs. coupling
			- inheritance increase coupling
		Strong coupling complicates a system
		design for weakest possible coupling

		if we do have to couple, it's better to couple to an interface rather than coupling to a implementation, this is mainly centered around statically type languages. In dynamically typed languages, we don;t really care so much about interface.

		High coupling is evil, means your code depends on a lot of things and it also depends on very strong dependecy on things, whereas low coupling means you depend on fewer number of things but also the things you depend on are much more lightweight dependecy like an interface rather than a concrete class. 

	- Cohesion

		Degree of connectivity among the elements of a single module or class. In other words, cohesion is talking about how much the different parts of an abstraction are related and work with each other. Cohesion makes a class very narrow and focused. Another term for cohesion is Single Responsibility Principle (SRP). 

		High cohesion is when it really becomes small and focused, does one thing and one thing well. Low cohesion is when it dilutes and bloats up and then just kind of spreads around like a blotting paper. It tries to do a lot of stuff, takes a lot of surface area. 

		Coincidental cohesion: all elements related undesirable
		Functional cohesion: work together to provide well-bounded behavior


	A good design have high cohesion and low coupling. 

	- Suffiency

		Implies minimal interface
		Captures enough characteristics for meaningful and efficent interaction

	- Completeness

		Interface captures all meaningful chracteristics of an abstraction
		Implies covering all aspects of an abstraction

	- Primitiveness (of operations/interface)

		Efficient implementation requires access to underlying representation.

		The methods, the operations we provide on an interface, on a class are really very small and basic implementation and they are really focues towards providing efficient implementation for whatever functionality we want.

		When it comes to functions, always try to provide minimum number of functions and also functions that are primitive.

3. Law of Demeter

	"Methods of a class should not depend in any way on the internal structure of any class, except the immediate structure of their own class. Further, each method should send messages to objects belonging to a very limited set of classes only."

	First part talks about encapsulation and cohesion. Second part talks about low coupling. 

4. Tell Don't Ask principle

	"Procedural code gets information and then makes decisions. OO code tells objects to do things" Alec Sharp in Smalltalk by Example.

	Objects should take limited responsibility and rely on others to provide appropraite service

	Command-Query Sepration: categorize methods as command or query

5. Train Wreck Coding

	You may find code that continues to call on objects return by methods in sequence

	customer.getAddress().getCity().getCounty()...

	This indicates that you are interest in working with objects that are farther away than those that are your close friend

	Hard to understand

	Hard to debug

	Lacks Cohesion

	Good candidate for refactoring



									Quiz Part 1

1. Design for high cohesion and low coupling.
2. A code that's narrow, focused, and does one thing well is considered to be cohesive.
3. A good design has to evolve.
4. Depending on an interface instead of a class can lead to loose coupling.
5. To create a good design we have to constantly evaluate the quality, evolve it and be consicous of our design activities not just get it working.




									Design Principles: Part 2

Stability - no reason to change
	Interface

Rigidity - there is reason to change, but we are extremely reluctant to change (afraid to make changes)


1. Bad Design

	- Rigidity - Hard to change, results in cascade of changes

		You know whether it is stability or rigidity by looking whether that is a class or an interface. If it is an interface it contributes to stability, if it's a class with dependecies it contributes to rigidity. 

	- Fragility - Breaks easily and often

		Low cohesion and high coupling causes fragility

	- Immobility - Hard to reuse (due to coupling)

		The reuse is inversely proportional to the level of coupling. The more the coupling, less the reuses, less the coupling, the more reusable the code can become.

	- Viscosity - Easy to do wrong things, hard to do right things
	- Needless Complexity - Complicated class design, overly generalized
	- Needless Repetition - Copy and Paste away
	- Opacity - Hard to understand

2. Principles

	Guiding Principles that help develope better systems

	Use principles only where they apply

	You must see the symptoms to apply them

	If you apply arbitrarily, the code ends up with Needless Complexity



									Quiz Part 2

1. Creating cryptic variables and terse code leads to opacity, a peril of bad design.
2. In desgin, tight coupling makes reuse hard not easy.
3. Fragility is proportional to coupling and inversely proportional to cohesion.
4. In desgin, in-coming dependencies lead to rigidity.
5. The ability to reuse is inversely proportional to coupling.




									Design Principles: Part 3

1. YAGNI Principles

	"You Aren't Going to Need It (yet)"

	You are looking out for extensibility
	You are not sure if a certain functionality is needed
	Designing what you do not know full leads to unnecessary complexity and heavy weight desgin
	If you really need it, design it at that time

2. DRY Principles

	"Don't Repeat Yourself"

	Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
	It is not just about duplication of code, it's about duplication of effort as well. 
	One of the most diffituclt, bust most seen

	Some time it is hard to realize we are violating the DRY principle
	It is much easier to copy, paste and modify code to get it working the way you wan it, but that's not the right way to do.
	Duplicating code results in poor maintainability, expensive to fix bugs/errors and hard to keep up with change.

3. SRP Principle

	"Single-Responsibility Principle" another name is cohesion

	A class should have only one reason to change

	SRP affects Reuse
		Lower cohesion results in poor reuse
		Tight coupling 
		Poor Cohesion
		Bad for reuse




									Quiz Part 3

1. Violating the DRY principles often may increase the cost of maintenance.
2. SRP can influence ease of code change, reduced cost of maintenance, readability and understandability.
3. DRY is not mainly about duplication of code but duplication of effort as well.
4. According to the DRY principle, we have to avoid duplicating code and effort.
5. The main concept or metric behind SRP is cohesion.





									Design Principles: Part 4

1. Nature of code

	"Software Systems change during their life time"

	Both better designs and poor designs have to face the changes; good designs are stable

2. Open Closed Principle

	"Software Entities (Classes, Modules, Functions, etc.) should be open for extension, but closed for modification" - Bertrand Meyer

	One way to make sure a software is extensible is really to rely upon an abstraction and not depend on the concrete type but on an abstract type

	Characteristics of a poor design:

		Single change results in cascade of changes
		Program is fragile, rigid and unpredictable

	Characteristics of a good design:

		Modules never change
		Extend Module's behavior by adding new code, not changing existing code


	A class must not depend on a Concrete class; it must depend on an abstract class

	Abstraction and Polymorphism are the key to extensibility






									Quiz Part 4

1. A poor design may be fragile, unpredictable and rigid
2. A good design is resilient, it will bounce back up from change
3. If we type check a reference for one of different types, then the code would be hard to extend, the code may be violoating OCP and the code may have to change more frequently
4. Strong coupling does not helps to make a code more extensible
5. To make code extensible, it rely on interfaces and polymorphism






									Design Principles: Part 5

1. OCP

	Strategic Closure:

		No program can be 100% closed

		There will always be changes against which the module is not closed

		Closure is not complete - it is strategic

		Designer must decide what kinds of changes to close the desgin for.

		This is where the experience and problem domain knowledge of the designer comes in

		To have good extensibility design we need both knowledge in the domain and software development

	Heuristics and Conventions that arise from OCP:

		Make all member variables private

		Encapsulation: All classes/code that depend on my class are closed from change to the variable names or their implementation within my class. Member functions of my class are never closed from these changes

		Further, if this were public, no class will be closed against improper changes made by any other class.

		No global variables

		Run-time type identification (RTTI) is ugly and dangerous 
		C++ - RTTI dynamic_cast
		Java - instanceof
		C# - is

		EXAMPLE: if (other.engine instanceof ...)  // this is bad and dangerous. What is wrong with this is that every time you introduce a new type of object, you would have to come back and change the code. We can prevent this by using polymorphism

		If a module tries to dynamically cast a base class pointer to several derived classes, any time you extend the inheritance hierarchy, you need to change the moduel.

		Not all these situation violate OCP all the time.






									Quiz Part 5

1. Closure is not complete, it's strategic
2. If we design a class for extensibility, the class sometimes have to change for any requirements change.
3. The use of Runtime Type Identification (RTTI) is NOT always a bad idea
4. Dependencies can be on both interface and class
5. Following the Open-Closed Principle can help us create code that is maintainable, more extensible, more decoupled and easier to change





















